//Code that interprets packets sent by the wifid 2.11BSD program.
/*
 * ----------------------------------------------------------------------------
 * "THE BEER-WARE LICENSE" (Revision 42):
 * Jeroen Domburg <jeroen@spritesmods.com> wrote this file. As long as you retain 
 * this notice you can do whatever you want with this stuff. If we meet some day, 
 * and you think this stuff is worth it, you can buy me a beer in return. 
 * ----------------------------------------------------------------------------
 */


#include <string.h>
#include "lwip/prot/ethernet.h"
#include "lwip/prot/ieee.h"
#include "lwip/prot/etharp.h"
#include "lwip/prot/ip.h"
#include "lwip/prot/ip4.h"
#include "lwip/ip4_addr.h"
#include "lwip/inet_chksum.h"
#include "lwip/prot/udp.h"
#include <esp_wifi.h>
#include "wifid.h"
#include "esp_netif_ip_addr.h"
#include "esp_netif_types.h"
#include "wifid_iface.h"
#include "wifi_if.h"
#include "hexdump.h"

#define WIFID_EVENT_ETHER_PKT_SZ (sizeof(struct eth_hdr)+sizeof(struct ip_hdr)+sizeof(struct udp_hdr)+sizeof(wifid_event_t))

static wifid_event_t *prepare_return_packet(char **pkt) {
	char *buffer=calloc(WIFID_EVENT_ETHER_PKT_SZ, 1);
	if (!buffer) return NULL;
	struct eth_hdr *eth=(struct eth_hdr*)buffer;
	memset(eth->dest.addr, 0xff, ETH_HWADDR_LEN); //bcast addr
	memset(eth->src.addr, 0xAA, ETH_HWADDR_LEN); //src addr, not really relevant
	eth->type=lwip_htons(0x0800); //ipv4
	struct ip_hdr *iphdr=(struct ip_hdr*)(buffer+sizeof(struct eth_hdr));
	IPH_VHL_SET(iphdr, 4, sizeof(struct ip_hdr) / 4);
	IPH_TOS_SET(iphdr, 0);
	IPH_LEN_SET(iphdr, lwip_htons(sizeof(struct ip_hdr)+sizeof(struct udp_hdr)+sizeof(wifid_event_t)));
	IPH_OFFSET_SET(iphdr, 0);
	IPH_TTL_SET(iphdr, 255);
	IPH_PROTO_SET(iphdr, IP_PROTO_UDP);
	IP4_ADDR(&iphdr->src, 192,168,254,254); //'from nowhere'
	IP4_ADDR(&iphdr->dest, 255,255,255,255);
	IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, sizeof(struct ip_hdr)));
	struct udp_hdr *uh=(struct udp_hdr*)(buffer+sizeof(struct eth_hdr)+sizeof(struct ip_hdr));
	uh->chksum=0;
	uh->dest=lwip_htons(PORT_RECV); //src/dst inverted as we send stuff _to_ wifid
	uh->src=lwip_htons(PORT_SEND);
	uh->len=lwip_htons(sizeof(struct udp_hdr)+sizeof(wifid_event_t));
	*pkt=buffer;
	return (wifid_event_t*)(buffer+sizeof(struct eth_hdr)+sizeof(struct ip_hdr)+sizeof(struct udp_hdr));
}

static void send_return_packet(char *ethpkt) {
	wifi_if_wifid_send_to_pdp(ethpkt, WIFID_EVENT_ETHER_PKT_SZ);
}

static void send_error_msg(const char *err) {
	char *resp_pkt;
	wifid_event_t *wev=prepare_return_packet(&resp_pkt);
	wev->resp=EV_ERROR;
	strcpy(wev->error.msg, err);
	send_return_packet(resp_pkt);
}

void wifid_signal_connected(esp_netif_t *netif, esp_netif_ip_info_t *ip) {
	char *resp_pkt;
	printf("wifid: signal connected\n");
	wifid_event_t *wev=prepare_return_packet(&resp_pkt);
	wev->resp=EV_GOT_IP;
	memcpy(&wev->connected.ip, &ip->ip.addr, 4);
	memcpy(&wev->connected.netmask, &ip->netmask.addr, 4);
	memcpy(&wev->connected.gw, &ip->gw.addr, 4);
	esp_netif_dns_info_t dns[3]={};
	esp_netif_get_dns_info(netif, ESP_NETIF_DNS_MAIN, &dns[0]);
	esp_netif_get_dns_info(netif, ESP_NETIF_DNS_BACKUP, &dns[1]);
	esp_netif_get_dns_info(netif, ESP_NETIF_DNS_FALLBACK, &dns[2]);
	for (int i=0; i<3; i++) memcpy(&wev->connected.nameserver[i], &dns[i].ip, 4);
	send_return_packet(resp_pkt);
}

static int send_error_on_disconnect=0;

void wifid_signal_noconnect() {
	if (send_error_on_disconnect) send_error_msg("Couldn't connect to AP");
}

void wifid_signal_scan_done() {
	char *resp_pkt;
	uint16_t ap_count;
	ESP_ERROR_CHECK(esp_wifi_scan_get_ap_num(&ap_count));
	printf("Scan done, %d results.\n", (int)ap_count);
	wifi_ap_record_t *ap_info=calloc(sizeof(wifi_ap_record_t), ap_count);
	ESP_ERROR_CHECK(esp_wifi_scan_get_ap_records(&ap_count, ap_info));
	for (int i=0; i<ap_count; i++) {
		wifid_event_t *wev=prepare_return_packet(&resp_pkt);
		wev->resp=(i==ap_count-1)?EV_SCAN_RES_END:EV_SCAN_RES;
		memcpy(wev->scan_res.ssid, ap_info[i].ssid, 32);
		wev->scan_res.rssi=ap_info[i].rssi;
		wev->scan_res.authmode=ap_info[i].authmode;
		printf("%d/%d\n", i, (int)ap_count);
		send_return_packet(resp_pkt);
		vTaskDelay(2);
	}
}

//Called when a packet from the PDP11 generated by wifid is called
void wifid_parse_packet(uint8_t *buffer, int len) {
	printf("wifid_parse_packet:\n");
	hexdump(buffer, len);
	wifid_cmd_t *wcmd=(wifid_cmd_t*)(buffer);
	if (wcmd->cmd == CMD_SCAN) {
		printf("WiFiD: Got SCAN commmand\n");
		esp_err_t r=esp_wifi_scan_start(NULL, false);
		if (r!=ESP_OK) {
			send_error_msg(esp_err_to_name(r));
		}
		//will generate WIFI_EVENT_SCAN_DONE event when done
	} else if (wcmd->cmd == CMD_CONNECT) {
		printf("WiFiD: Got CONNECT commmand: SSID `%s` pass `%s`\n", wcmd->connect.ssid, wcmd->connect.pass);
		wifi_config_t wifi_cfg = {};
		strncpy((char*)wifi_cfg.sta.ssid, wcmd->connect.ssid, sizeof(wifi_cfg.sta.ssid));
		strncpy((char*)wifi_cfg.sta.password, wcmd->connect.pass, sizeof(wifi_cfg.sta.password));
		wifi_cfg.sta.pmf_cfg.capable = true;
		wifi_cfg.sta.pmf_cfg.required = false;
		esp_err_t r=esp_wifi_set_config(ESP_IF_WIFI_STA, &wifi_cfg);
		if (r==ESP_OK) {
			send_error_on_disconnect=0;
			wifi_if_ena_auto_reconnect(0);
			esp_wifi_disconnect();
			vTaskDelay(1000/portTICK_PERIOD_MS); //hacky, should perhaps use a callback from the disconnect event?
			printf("connect\n");
			wifi_if_ena_auto_reconnect(1);
			send_error_on_disconnect=1;
			r=esp_wifi_connect();
		}
		if (r!=ESP_OK) {
			send_error_msg(esp_err_to_name(r));
		}
		//will generate IP_EVENT_STA_GOT_IP when done
	} else if (wcmd->cmd == CMD_QUIT) {
		//Ignore, we aren't the one needing to quit here.
	} else {
		printf("WiFiD: Got unknown commmand %ld\n", wcmd->cmd);
		char buff[32];
		sprintf(buff, "Unknown cmd %ld", wcmd->cmd);
		send_error_msg(buff);
	}
}
